---
layout: post
title:  "프로세스 관리-01"
date:   2018-07-08
author: EunHye Jung
categories: os
comment : true
tags:	운영체제 OpeartingSystem OS
cover:  "/assets/instacode.png"
---
   
   
### 프로세스의 개념    
  
* 실행중인 프로그램 : program in execution  
  디스크에 존재하던 프로그램이 메모리에 적재됨.  
  프로그램이 CPU를 할당받아서 기계명령(instruction)을 수행하고 있는 상태.  
* 일반적으로 JOB이라는 용어와 프로세스를 혼용하여 사용하기도함!  
  
* 프로세스 문맥 : 프로세스가 어떤 상태에서 수행되고 있는지를 정확히 설명하기 위해 필요한 정보  
  그 프로세스의 주소공간(코드, 데이터 스택 상태)을 비롯해 레지스터에 어떤 값을 가지고 있는지와  
  시스템 콜등을 통해 커널에서 수행한 일의 상태, PCB등을 포함!  
* 프로세스 문맥을 크게 세가지로 분류하면,  
  `하드웨어 문맥`, `프로세스의 주소공간`, `커널 상의 문맥`으로 나누어 볼 수 있다.   
  이때, 하드웨어 문맥은 CPU의 수행상태를 나타내는것으로 프로그램 카운터값과 각종 레지스터에 저장되고 있는 값들을 의미한다.   
   
- - -
   
### 프로세스의 상태   
  
  ![content01](/assets/contents/content07.PNG)  
  
* 프로세스의 상태는 `실행(running)`, `준비(ready)`, `봉쇄(blocked, wait, sleep)` 세가지로 구분할 수 있다.  
  * `실행상태` : 프로세스가 CPU를 보유하고 있고, 기계어명령을 실행중인 상태  
  * `준비상태` : 프로세스가 CPU를 보유하면 당장 명령을 실행할 수 있지만, CPU를 할당받지 못한 상태.  
  * `봉쇄상태` : 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태.  
* 이밖에도, 프로세스가 생성중이거나 종료중인 일시적인 상태를 각각 `시작(new)`, `완료(terminated)` 상태라 부른다.  
  * `시작상태` : 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만, 아직 메모리 획득을 승인받지 못한 상태.  
  * `완료상태` : 프로세스가 종료되었지만, 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리되지 못한 상태.  
  
* 하나의 프로세스는 어느 한 상태에 머물러있다.  
  예를 들어, 실행상태에서 CPU의 제어권을 가지고 프로세스가 실행되는 중에,  
  `타이머 인터럽트`가 발생하면, CPU의 제어권이 운영체제로 넘어간다.  
  그러면 운영체제는 `타이머 인터럽트 처리 루틴`으로 가서 수행중이던 프로세스의 문맥을 저장하고,  
 준비 상태에 있는 프로세스 중에서 새롭게 CPU 제어권을 넘길 프로세스를 선택하게 된다.  
  -> 이처럼 실행시킬 프로세스를 변경하기 위해 원래 수행중이던 프로세스 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정을 `문맥 교환(context switch)`이라고 한다.  
  `문맥교환`이 일어날때는 타이머 인터럽트가 발생하는 경우 외에도, 실행 상태에 있던 프로세스가 입출력 요청 등으로 봉쇄상태로 바뀌는 경우를 들 수 있다.  
* 준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨주는 과정을 `CPU 디스패치(dispatch)`라고 한다.   
* CPU가 실행상태에 있따는 것은 CPu를 할당받고, 기계어 명령을 하나씩 수행하고 있는것을 의미하는데, 경우에 따라서는 디스크에서 파일의 내용을 읽어와야 하는 명령이 포함될 수 있다.  
  이럴 경우 읽어온 결과가 있어야 후속명령을 수행할 수 있으니 디스크 입출력이 진행되는 동안에는 이 프로세스가 CPU를 점유하고 있어도 후속 명령을 처리하지 못한다. ->  CPU가 비효율적으로 낭비된다.  
  (디스크에서 파일을 읽어오는 작업은 상당한 시간이 소요되는 작업이다!)   
  따라서 입출력이 완료될때까지 CPU를 반환한다음, 디스크 입출력 서비스를 기다리는 장치큐에 가서 줄을 서게 된다. 이때, 프로세스의 상태는 `봉쇄상태`가 된다.  
  그러면, CPU를 기다리는 준비큐에 줄 서 있는 프로세스들중에서 `CPU 스케줄러`가 적절한 프로세스를 하나 선정해서 CPU를 할당하게 된다.  
* CPU를 기다리는 `준비큐`에는 CPU만 획득하면 곧바로 명령을 수행할 수 있는 프로세스들만 줄서 있게 된다. -> 준비상태  
  (입출력 등 오래 기다려야 하는 업무가 진행중인 프로세스는 줄을 못슴!)  
  `준비 상태`의 프로세스 들중에서 이번에 CPU를 할당받은 프로세스의 상태는 `실행상태`로 변경된다.  
* 디스크 입출력을 요청한 프로세스는 디스크 입출력을 기다리는 장치큐에 줄 서 있다가, 자기차례가 되어 디스크 컨트롤러로부터 서비스를 받는다.  
  원하는 데이터를 로컬 버퍼로 읽어들이고 나면, 디스크 컨트롤러가 CPU에게 인터럽트를 발생시켜서 입출력이 완료되었다는것을 알리게 된다.  
  그러면 CPU는 어떤 프로세스를 실행하고 있다가, 인터럽트가 발생한것을 확인하고 그에 대응하는 루틴을 수행하게 된다.  
 이 루틴이 수행되는 동안 CPU에서 수행하던 프로세스의 상태는 `사용자모드 실행상태`에서 `커널모드 실행상태`로 바뀌게 된다.  
 이 루틴이 하는 일은 입출력이 완료된 프로세스를 `장치큐`에서 빼내어 CPU를 기다리는 `준비큐`에 넣어주고, 프로세스의 상태를 준비상태로 바꾼 후 장치의 로컬버퍼에 있는 내용을 메모리로 이동시키는 일이다.  
* 인터럽트 처리가 끝나면 인터럽트 처리 루틴 이전에 수행되던 프로세스에게 CPU를 다시 할당해 그 프로세스의 상태가 `커널모드`에서 다시 `사용자모드` 실행상태로 변경되도록 한다.  
  경우에 따라서는 인터럽트 당한 프로세스에게 CPU를 다시 할당하지 않고, 입출력이 완료된 프로세스가 더 우선순위가 높은 프로세스의 경우 문맥교환을 통해 CPU 제어권을 이양시키는 경우도 발생할 수 있다. -> `CPU 스케줄링` 방법에 따라 달라짐!    
   
   
- - - 
    
    
### 프로세스 제어 블록(PCB : Process Control Block)
    
* `프로세스 제어 블록` : 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보를 담는 커널내의 자료구조  
* PCB는 다음과 같은 요소들로 구성된다.  
  * 프로세스의 상태(process state) : CPU를 할당해도 되는지 여부를 결정   
  * 프로그램 카운터 값(program counter) : 다음수행할 명령의 위치를 가리킴   
  * CPU 레지스터 (CPU register) : CPU연산을 위해 현시점에 레지스터에 어떤 값을 저장하고 있는지 나타냄.   
  * CPU 스케줄링 정보 (CPU scheduling information)     
  * 메모리 관리정보 (memory management information)    
  * 자원 사용정보 (acounting information)   
  * 입출력 상태 정보(I/O status information)  
   
   
- - -
   
   
### 문맥교환 (Context Swtich)  
   
* `문맥 교환` : 하나의 프로세스로부터 다른 프로세스로 CPU의 제어권이 이양되는 과정.  
* 문맥 교환 중 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터 값 등 프로세스의 문맥을 자신의 PCB에 저장하고,  
  새롭게 CPU를 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원시키는 과정을 거친다.  
* 문맥교환은 타이머 인터럽트가 발생하는 경우 외에도 실행중이던 프로세스가 입출력 요청이나 다른 조건을 충족하지 못해 CPU를 회수당하고 봉쇄상태가 되는 경우에도 발생할 수 있다.  
* 프로세스가 실행 상태일때, `시스템 콜`이나 `인터럽트`가 박ㄹ생하면, CPU의 제어권이 운영체제에게로 넘어와 운영체제 커널의 코드가 실행된다. (원래 실행중이던 프로세스 업무는 잠시 멈춤)  
  이 경우에도, 프로세스 문맥 중 일부를 PCB에 저장하게 되지만 이러한 과정을 문맥교환이라고 하지는 않는다.  
  이는 하나의 프로세스가 `사용자 모드`에서 실행되다가 `커널 모드`로 실행 모드만 바뀌는 것일뿐, CPU를 점유하는 프로세스가 다른 프로세스로 변경되는 과정이 아니기 때문이다.  
* 타이머 인터럽트가 발생하거나 프로세스가 입출력 요청 시스템콜을 하여 봉쇄상태에 들어가는 경우에는 문맥교환이 일어나지만, 그밖의 인터럽트나 시스템콜 발생시에는 문맥교환이 일어나지 않고 모드 변경만 있을 뿐이다.  
* 문맥 교환에 소요되는 시간은 시스템 입장에서 볼때, 일종의 오버헤드라고 할 수 있다.  
  -> 적절한 CPU 할당 시간을 정하는 것이 중요!   

   
- - -
    
[출저](https://book.naver.com/bookdb/book_detail.nhn?bid=4392911)  
   
     
     
