---
layout: post
title:  "메모리 관리-01"
date:   2018-07-16
author: EunHye Jung
categories: os
comment : true
tags:	운영체제 OpeartingSystem OS
cover:  "/assets/instacode.png"
---
   
   
### 메모리와 관련된 용어   
   
<b> 동적로딩 (dynamic loading) </b>  
* 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법중 하나.  
* 동적로딩에서는 프로세스가 시작될때, 그 프로세스의 주소 공간 전체를 메모리에다 옮겨놓는것이 아니라, 해당 루틴이 불러질때, 그 루틴안 메모리에 적재하는 방식을 사용한다.  
  -> 즉, 프로세스 내에서 실행에 필요한 루틴이 실제로 불릴때마다 메모리에 적재하는 것을 말함.   
* 동적 로딩 기법은 사용되지도 않을 많은 양의 코드가 메모리에 올라가는 것을 막아 메모리 사용의 효율을 높인다.  
   
<b> 동적 연결 (dynamic linking) </b>   
* `연결(linking)`은 개발자가 작성한 소스코드를 컴파일하여 생성된 목적파일(object file)가 이미 컴파일된 라이브러리 파일(library file)들을 묶어서 실행파일을 생성하는 것을 말함.  
* `동적 연결`은 컴파일을 통해 생성된 목적파일과 라이브러리 파일 사이의 연결을 프로그램의 실행시점까지 지연시키는 기법을 뜻한다.  
  동적 연결에서는 실행 파일에 라이브러리 코드가 포함되지 않으며, 프로그램 실행 중 라이브러리 함수가 호출될때, 라이브러리에 대한 연결이 이루어진다.  
* 동적 연결을 가능하게 하기 위해 실행 파일의 라이브러리 호출 부분에 `스텁(stub)`이라는 작은 코드를 둔다.  
  라이브러리 호출시 스텁을 통해 해당 라이브러리가 메모리에 이미 존재하는지 살펴보고,  
  그럴 경우 그 루틴의 주소에 가서 메모리에서 직접 참조하고 그렇지 않을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리에 적재한 후 수행하게 된다.  
* 동적 연결에서는 다수의 프로그램이 공통적으로 사용하는 라이브러리를 메모리에 한번만 적재하므로 메모리 사용의 효율성을 높일 수 있다.  
   
<b> 중첩 (overlays) </b>  
* `중첩(overlay)`란 프로세스의 주소 공간을 분할해 실제 필요한 부분만 적재하는 기법을 말한다.  
* 동적 로딩과 개념적으로 유사하나, 동적로딩과 중첩을 사용하는 이유는 상이하다.  
* 중첩은 프로그램의 크기가 물리적 메모리의 크기에 비해 작다면, 주소 공간 전체를 한꺼번에 올릴 수 있지만 그렇지 않으면 분할해 올린다.
* 동적 로딩은 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도로 사용하는 반면, 중첩은 단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택이었다.   
   
<b> 스와핑 (swapping)</b>    
* `스와핑(swapping)`이란 메모리에 올라온 프로세스이 주소 공간 전체를 디스크의 스왑 영역(swap area)에 일시적으로 내려놓는 것을 말한다.  
  이때, 스왑 영역은 `백킹 스토어(backing store)`라고도 부르며, 디스크 내에 파일 시스템과의 별도로 존재하는 일정 영역을 말한다.  
* 파일 시스템은 전원이 나가더라도 그 내용이 유지되어야 하는 비휘발성 저장 공간임에 비해 스왑영역은 프로세스가 수행중인 동안에만 디스크에 일시적으로 저장하는 공간이므로 저장기간이 상대적으로 짧은 저장공간이라고 할 수 있다.  
* 스왑 영역은 다수의 사용자 프로세스를 담을 수 있을만큼 충분히 큰 저장공간이어야 하고 어느 정도의 접근 속도가 보장되어야 한다.   
* 디스크에서 메모리로 올리는 작업을 `스왑 인(swap in)`, 메모리에서 디스크로 내리는 작업을 `스왑 아웃(swap out)`이라고 부른다.  
    
    
- - -   
    
### 주소 바인딩   
   
* 프로그램이 실행을 위해 메모리에 적재되면, 그 프로세스를 위한 독자적인 주소 공간이 생성된다.  
  이 주소를 `논리적 주소(logical address)` 혹은 `가상 주소(virtual address)`라고 부른다.  
  CPU는 이와 같이 프로세스마다 독립적으로 갖는 논리적 주소에 근거해 명령을 실행한다.  
  (논리적 주소는 각 프로세스마다 독립적으로 할당되며, 0번지부터 시작됨.)   
* `물리적 주소(physical address)`는 물리적 메모리에 실제 올라가는 위치를 말한다.  
  (프로세스가 실행되기 위해서는 해당 프로그램이 물리적 메모리에 적재되어 있어야 한다.)   
* 또한, CPU가 기계어 명령을 수행하기 위해 논리적 주소를 통해 메모리를 참조하게 되면,  
  해당 논리적 주소가 물리적 메모리 주소의 어느 위치에 매핑되는지를 확인해야 한다.  
  이와 같이 프로세스의 논리적 주소를 물리적 주소로 연결해주는 작업을 `주소 바인딩(address binding)`이라고 한다.  
  
* 주소바인딩 방식으로는 `컴파일 타임 바인딩`, `로드 타임 바인딩`, `실행시간 바인딩` 세가지가 있다.  
  프로그램이 적재되는 물리적 메모리 주소가 언제 결정되는지에 따라 분류한다.  
* `컴파일 타임 바인딩`에서 프로그램이 올라가 있는 물리적 메모리의 위치를 변경하고 싶을때는 다시 컴파일해야 한다.  
  비현실적인 방식이고, 현대의 시분할 컴퓨팅환경에서는 잘 사용되지 않는 기법이다.  
* `로드 타임 바인딩`은 프로그램이 실행될때, 물리적 메모리가 결정된다.  
  이 바인딩 방식에서는 로더(loader)의 책임하에 물리적 메모리가 부여되며, 프로그램이 종료될때까지 물리적 메모리상의 위치가 고정된다.  
  `로더(loader)`란 사용자 프로그램을 메모리에 적재시키는 프로그램을 말한다.  
* `실행 시간 바인딩`은 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식이다.  
  이 방식에서는 CPU가 주소를 참조할때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소매핑테이블을 이용하여 바인딩을 점검해야 한다.  
  또한, 다른 방식들과 달리 실행시간 바인딩이 가능하기 위해서 기존 레지스터와 한계레지스터를 포함해 MMU(Memory Management Unit)라는 하드웨어적인 자원이 필요하다.  
  `MMU`는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치이다.  
  MMU 기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는것으로 가정한다.  
* 프로세스는 자기 자신만의 고유한 주소 공간을 가지고 있으므로, 동일한 주소값이라 하더라도 각 프로세스마다 서로 다른 내용을 담고 있게 된다.  
  따라서, CPU가 논리적 주소 100번지를 참조한다고 할때, 현재 CPU에서 어떤 프로세스가 수행되고 있느냐에 따라 이 100번지가 가리키는 내용은 상이하다.   
   
     
- - -  
    
[출저](https://book.naver.com/bookdb/book_detail.nhn?bid=4392911)  
   
     
     
