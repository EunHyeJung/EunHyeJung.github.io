---
layout: post
title:  "디스크 관리 (디스크 구조, 디스크 스케줄링)"
date:   2018-07-30
author: EunHye Jung
categories: os
comment : true
tags:	운영체제 OpeartingSystem OS
cover:  "/assets/instacode.png"
---

   
    
*  디스크는 컴퓨터 시스템의 대표적인 2차 저장장치이다.  
* 메모리는 휘발성 저장 장치 이므로, 전원이 나가면 그 내용이 모두 사라지게 된다.  
  따라서, 컴퓨터에서 수행한 작업의 결과를 영구적으로 보관하기 위해서는 디스크와 같은 2차 저장장치를 이용해야 한다.  
   
   
- - -   
  
  
### 디스크의 구조   
    
* 디스크의 외부에서는 디스크를 일정한 크기의 저장 공간들로 이루어진 1차원 배열들로 취급하게 된다.    
  이 일정한 크기의 저장 공간들은 `논리 블록(logical block)`이라고 하며, 디스크에 데이터가 저장될때에는 논리블록 단위로 저장되고, 디스크 외부로 입출력이 일어날 때에도 논리블록단위로 전송된다.  
* 논리 블록에 저장된 데이터에 접근하기 위해서는 배열에 접근하는것처럼 해당 블록의 인덱스 번호를 디스크에 전달해야한다.  
  그러면 디스크 컨트롤러는 해당 논리 블록이 저장된 물리적 위치를 찾아 요청된 데이터에 대한 입출력 작업을 수행하게 된다.   
  이때, 각 논리 블록이 저장되는 디스크내의 물리적인 위치를 `섹터`라고 한다.  
  즉, 논리 블록 하나가 섹터 하나와 1대 1로 매핑되어 저장되는 것이다.  
* 디스크의 물리적은 구조는 마그네틱의 원판으로 구성된다.  
  하나의 디스크 내의 원판의 수는 하나일수도 있고, 여러개일수도 있다.  
  각각의 원판은 `트랙(track)`으로 구성되고, 각 트랙은 섹터로 나뉜다.  
* 섹터에 최소한의 단위 정보가 저장된다.  
  여러개의 원판에서 상대적인 위치가 동일한 트랙들의 집합을 `실린더(cylinder)`라고 부른다.   
* 디스크에 데이터를 읽고 쓰기 위해서는 암(arm)이 해당 섹터가 위치한 실린더로 이동한 후 원판이 회전하여 디스크 헤더가 저장된 섹터 위치에 도달하여야 한다.  
  
  
![content01](/assets/contents/os_content12.png)    
  
   
- - -   
   
   
### 디스크 스케줄링   
   
* 디스크에 대한 접근시간은 탐색시간과 회전지연시간, 전송시간으로 구성된다.   
  
* <b> 탐색 시간(Seek Time) </b>   
  디스크 헤드를 해당 실린더로 이동하는데 걸리는 시간  
* <b> 회전 지연 시간 (Rotational Latency Time) </b>     
  디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간   
* <b> 전송 시간 (Transfer Time) </b>   
  해당 섹터가 헤드 위치에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는데 소요되는 시간.   
   
* 디스크 입출력의 효율을 높이기 위해서는 디스크 입출력에 소요되는 접근시간을 최소화해야한다.  
  회전지연시간과 전송시간은 상대적인 수치가 작을뿐만 아니라 운영체제 입장에서 통제하기 힘든 부분이다.  
  따라서 운영체제는 탐색 시간을 줄이기 위해 헤드의 움직임을 최소화하는 스케줄링 작업을 한다.  
* `디스크 스케줄링`이란 효율적인 디스크 입출력을 위해 여러 섹터들에 대한 입출력 요청이 들어왔을때, 이들을 어떠한 순서로 처리할것인지 결정하는 매커니즘을 말한다.  
  디스크 스케줄링의 가장 중요한 목표는 `디스크 헤더의 이동 거리를 줄이는것`이다.   
  
    
#### FCFS (First-Come-First-Served) 스케줄링   
   
디스크에 먼저 들어온 요청을 먼저 처리하는 방식   
FCFS 스케줄링이 적용되는 디스크에서 최악의 경우, 입출력 요청이 디스크의 한쪽끝과 반대쪽끝에 번갈아 도착한다면, 디스크는 계속 왕벽하며 일을 처리해야 하므로 탐색시간이 매우 많이 늘어날 수 있다.  
   
요청순서 : 99 　  184 　   36 　   123 　   15 　   125 　   66 　   68    
현재 디스크 헤드위치가 54번 실린더에 있을때  
디스크헤드가 움직이는 경로  : 54 　  99 　  184 　   36 　   123 　   15 　   125 　   66 　   68    
총 헤드가 이동한거리 : 644  
  
  
_ _ _   
   
    
#### SSTF (Shortest-Seek-Time-First)  
  
헤드의 현재 위치부터 가장 까까운 위치에 있는 요청을 제일 먼저 처리하는 알고리즘.  
SSTF 기법은 헤드의 이동거리를 줄여 디스크 입출력의 효율성을 증가시키지만, `기아 현상(starvation)`을 발생시킬 수 있다.  
현재 헤드 위치로부터 가까운 곳에 지속적인 요청이 들어온 경우 헤드 위치에서 멀리 떨어진 요청은 무한히 기다려야하는 문제가 발생할 수 있게 때문이다.  
  
요청순서 : 99 　  184 　   36 　   123 　   15 　   125 　   66 　   68    
현재 디스크 헤드위치가 54번 실린더에 있을때  
디스크헤드가 움직이는 경로  : 54 　  66 　  68 　   36 　   15 　   99 　   123 　   125 　   184    
총 헤드가 이동한거리 : 236  
   
   
_ _ _   
   
   
#### SCAN 알고리즘    
   
   
헤드가 디스크 원판의 한쪽 끝에서 다른 한쪽끝으로 이동하며 그 경로에 존재하는 모든 요청을 처리한다.    
즉, 디스크의 어떠한 위치에 요청이 들어오는것과는 관계없이 헤드는 정해진 방향으로 이동하면서 길목에 있는  요청을 처리하면서 지나가는것이다.  
SCAN 알고리즘이 한 방향으로 이동하여 디스크의 한쪽끝에 도달하면, 방향을 바꾸어 다른쪽 끝을 향해 이동해 그 경로에 있는 모든 요청을 처리한다.  
SCAN 알고리즘은 엘레베이터 스케줄링 알고리즘이라고도 불린다.  
(한 방향으로 이동하면서 진행경로에 같은 방향으로 가는 승객이 있으면 모두 태움.)   
FCFS처럼, 불필요한 이동이 발생하거나 SSTF처럼 일부 지역이 지나치게 오래 기다리는 현상이 발생하지 않는다. 즉, 효율성과 형평성을 모두 만족한 알고리즘이라고 할 수 있다.  
하지만, SCAN알고리즘에서 모든 실린더위치의 기다리는 시간이 공평한 것은 아니다.  
제일 안쪽이나 제일 바깥쪽보다는 가운데 위치가 기다리는 평균시간이 더 짧기 때문이다.  
SCAN 알고리즘의 위치에 따른 탐색시간의 편차를 보완하기 위해 C-SCAN 알고리즘이 고안되었다.  
  
요청순서 : 99 　  184 　   36 　   123 　   15 　   125 　   66 　   68    
현재 디스크 헤드위치가 54번 실린더에 있을때  
디스크헤드가 움직이는 경로  : 54 　  36 　  15 　   0 　   66 　   68 　   99 　   123 　   125 　   128    
총 헤드가 이동한거리 : 238  
   
   
_ _ _   
   
   
#### C-SCAN (Circular-SCAN)   
   
C-SCAN은 SCAN과 달리 헤드가 다른쪽 끝에 도달해 방향을 바꾼 후에는 요청을 처리하지 않고, 곧바로 출발점으로 다시 이동만 한다.  
이 방식은 SCAN보다 각 실린더 위치에 대해 좀 더 균일한 탐색시간을 제공한다.  
즉, SCAN보다 헤드의 이동거리는 조금 길어질 수 있지만, 탐색시간의 편차를 줄일 수 있다.  
   
요청순서 : 99 　  184 　   36 　   123 　   15 　   125 　   66 　   68    
현재 디스크 헤드위치가 54번 실린더에 있을때  
디스크헤드가 움직이는 경로  : 54 　  66 　  68 　   99 　   123 　   125 　   184 　  0 　   15 　   36    
총 헤드가 이동한거리 :  380
    
   
_ _ _   
   
   
#### LOOK과 C-LOOK  
   
SCAN 알고리즘은 요청의 존재 여부와 관계없이 헤드가 무조건 디스크의 한쪽끝에서 다른쪽 끝으로 이동한다.  
이에 비해 `LOOK`은 한쪽방향으로 이동중이다가 그 방향으로 전방에 더 이상 대기중인 요청이 없으면, 헤드의 이동방향을 즉시 반대방향으로 바꾸는 스케줄링 방식이다.  
`C-LOOK`은 전방에 요청이 없을 때, 방향을 바꾼다는 측면에서는 LOOK과 유사하며, 한쪽방향으로 이동할때에만 요청을 처리한다는 점에서 C-SCAN과 유사하다.  
SCAN,C-SCAN 및 이들을 활용한 LOOK, C-LOOK 등의 스케줄링 알고리즘이 디스크 입출력이 많은 시스템에서 FCFS나 SSTF에 비해 효율적인것으로 알려져 있다.   
  
  
- - -   
    
[출저](https://book.naver.com/bookdb/book_detail.nhn?bid=4392911)  
   
   

