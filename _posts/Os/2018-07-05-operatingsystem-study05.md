---
layout: post
title:  "인터럽트의 원리"
date:   2018-07-05
author: EunHye Jung
categories: os
comment : true
tags:	운영체제 OpeartingSystem OS
cover:  "/assets/instacode.png"
---
   
   
### 프로그램 구조와 인터럽트   
  
* 프로그램이 CPU에서 명령을 수행하려면, 주소 영역이 메모리에 올라가 있어야한다.  
* 프로그램의 주소 영역은 크게 `코드`, `데이터`, `스택` 영역으로 구분된다.  
   * 코드 영역 : 우리가 작성한 프로그램 코드들이 기계어 명령으로 변환되어 저장되는 부분.  
   * 데이터 영역 : 전역변수 등 프로그램이 사용하는 데이터를 저장하는 부분.  
   * 스택 영역 : 함수가 호출될때 호출된 함수의 수행을 마치고, 복귀할 주소 및 데이터를 임시로 저장하는데 사용  
  
* 인터럽트의 동작원리는 함수 호출과 비슷하다.  
  A라는 프로그램이 CPU를 할당받아 명령을 수행하고 있는데, 인터럽트가 발생하면 A는 현재 수행중인 명령어의 위치를 저장(PCB에)  
* 운영체제는 현재 실행중인 모든 프로그램을 관리하기 위한 자료구조인 `프로세스 제어 블록(PCB, Process Control Block)`을 가지고 있다.  
  
- - -   
  
### 컴퓨터 시스템의 작동    
  
* CPU는 현재 수행해야할 메모리 주소 명령을 있는 그대로 처리할 뿐이다.  
  CPU가 수행해야할 메모리 주소를 담고있는 레지스터를 `프로그램 카운터(Program Counter, PC)`라고 한다.  
* CPU가 수행해야 하는 명령어에는 `일반명령`과 `특권명령`이 있다.  
  `일반명령`은 메모리에서 자료를 읽어와서, CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들을 말하며, 일반 명령은 모든 명령이 수행가능하다.  
  `특권명령`은 보안이 필요한 명령으로, 입출력장치, 타이머 등 각종 장치에 접근하는 명령을 말하며, 항상 운영체제만 실행가능하다.  
  
* 컴퓨터 시스템은 이 두명령의 실행가능성을 체크하기 위해, CPU내에 `모드 비트(mode bit)`를 둔다.  
  사용자 프로그램은 디스크파일에 접근하거나 수행결과를 화면에 출력하는 등의 특권 명령이 수행할 필요가 있을때, 운영체제에 인터럽트를 걸어서 특권명령을 대행해줄것을 요청한다. 이것을 `시스템 콜(system call)`이라고 한다.  
  사용자 프로그램이 시스템 콜을 하게 되면, 운영체제는 사용자 프로그램의 코드가 아닌 자신의 커널 영역에 정의된 시스템 콜 처리코드를 수행하게 된다.   
  
  
- - -
   
### 프로그램의 실행  
   
* 프로그램이 실행되고 있는것은 컴퓨터 시스템 차원에서 크게 두가지 중요한 의미를 가진다.  
  * 디스크에 존재하던 실행파일이 메모리에 적재됨.  
  * 프로그램이 CPU를 할당받고, 기계명령(instruction)을 수행하고 있는 상태.  
     
* 프로그램의 주소공간 중 당장 필요한 부분은 메모리에 올려놓고, 그렇지 않은 부분은 디스크 중 메모리의 연장공간으로 사용되는 스왑영역에 내려놓는다.  
* 프로그램의 주소 공간은 `코드(code)`, `데이터(data)`, `스택(stack)` 등으로 구성된다.  
  각각의 프로그램마다 이러한 주소 공간을 별도로 가지며, 각 프로그램마다 독자적으로 존재하는 이와같은 주소공간을 우리는 가상메모리(virtual memeory) 또는 논리적 메모리(logical memory)라고 부른다.  
  
  ![content01](/assets/contents/content04.PNG)  
  
* 운영체제도 하나의 프로그램이므로 운영체제 커널 역시 코드, 데이터, 스택의 주소 공간을 가지고 있다.  
   * 커널의 코드는 CPU, 메모리 등의 자원을 관리하기 위한 부분과 사용자에게 편리한 인터페이스를 제공하기 위한 부분이 주를 이루고 있다.  
     그 외에도 커널의 코드는 시스템콜 및 인터럽트를 처리하기 위한 부분도 포함된다.  
   * 커널의 데이터 영역에는 각종 자원을 관리하기 위한 자료구조가 저장된다.  
     각 프로세스의 상태, CPU 사용정보, 메모리 사용정보 등을 유지하기 위한 자료구조인 PCB도 커널의 데이터영역에 존재한다.  
   * 커널의 스택영역은 함수 호출시의 복귀주소를 저장하기 위한 용도로 사용한다.  
    커널의 스택은 현재 수행중인 프로세스마다 별도의 스택을 두어 관리한다.  
    프로그램이 실행되어 자기 자신의 코드내에서 함수호출 및 복귀주소를 유지하기 위해서는 자기주소 공간내의 스택을 활용하고, 시스템 콜 등 커널 내의 함수를 호출하는 겨웅에는 커널의 주소공간에 존재하는 커널스택을 이용한다.   
  
  
- - -
   
### 사용자 프로그램이 사용하는 함수  
   
* 프로그램이 사용하는 함수는 크게 `사용자 정의 함수`와 `라이브러리 함수`, `커널 함수`의 세가지로 구분한다.  
  
  *  사용자 정의 함수 : 개발자가 직접 장성한 함수  
  *  라이브러리 함수 : 이미 누군가가 작성해놓은 함수를 호출만 하여 사용하는 경우  
  *  커널 함수 : 운영체제 커널의 코드에 정의도니 함수, 커널 함수의 종류로는 시스템콜 함수, 인터럽트 처리함수가 있음  
   
- - -
   
### 인터럽트  
  
* 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 나누어 볼 수 있으며, 일반적으로는 하드웨어 인터럽틀르 의미한다.  
* CPU는 특별한 일이 없으면 현재 수행중인 프로세스의 다음 명령을 순차적으로 수행한다.  
  CPU는 프로그램 카운터가 가르키는 곳에 있는 명령을 수행하는 일밖에 하지 않기 때문에, 현재 수행중인 프로세스로부터 CPU를 회수해 CPU가 다른 일을 하도록 하려면, `인터럽트 매커니즘`이 필요하다.  
일반적으로 CPU가 아닌 다른 하드웨어 장치가 CPU에게 서비스를 요청할 경우, CPU내에 인터럽트 라인을 세팅해서 인터럽트를 발생시킨다.  
CPU는 매번 프로그램 카운터가 있는 지점의 명령을 하나씩 수행하고나서 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지를 체크한다.  
인터럽트 라인 체크를 통해 인터럽트가 발생했으면 CPU는 현재 수행하던 프로세스를 멈추고 운영체제의 인터럽트 처리 루틴으로 이동해서 인터럽트를 수행한다.  
특정 프로세스가 CPU를 독점하는것을 막기위해 운영체제는 타이머 인터럽트를 사용한다.  
  
* 소프트웨어가 발생시키는 인터럽트는 `트랩(trap)`이라 하며, 트랩의 종류에는 `예외상황(exception)`과 시스템 콜(system call) 두 종류가 있다. 
  * `예외상황`은 프로그램이 허용되지 않은 연산을 하려고 할때, 자동적으로 발생하는 것이다. 
운영체제는 예외상황이 발생했을때, CPU의 제어권을 획득해 해당 상황에 대한 조치를 취한다.  
예외 상황의 예로는 0으로 나누는 연산(divide-by-zero), 자신의 주소 공간을 넘어서는 메모리 참조 등이 해당됨.  
  * `시스템 콜`은 사용자 프로세스가 운영체제의 서비스를 요청하기 위해 커널의 함수를 호출하는 것이다.  
사용자 프로세스가 직접 특권명령을 수행할 수 없으므로, 특권 명령을 수행하려 할때 시스템콜을 사용하는 것이다.  
  
* 인터럽트와 관련된 주요 용어로는 `인터럽트 벡터(interrupt vector)`와 `인터럽트 핸들러(interrupt handler)`가 있다.  
* `인터럽트 벡터`란 인터럽트 발생시 처리해야할 루틴의 주소를 보관하고 있는 테이블을 의미한다.  
  (일종의 함수를 가리키는 포인터(pointer)라고 할 수 있음.)   
* `인터럽트 핸들러`는 실제 인터럽트를 처리하기 위한 루틴으로, 인터럽트 서비스 루틴이라고도 한다.  
  
* 인터럽트 처리를 마치고 나면, 인터럽트가 발생하기 직전의 프로세스에게 CPU의 제어권이 다시 넘어가게 된다.  
   
- - -
   
### 프로세스의 상태   
  
* 프로세스의 상태는 크게 `실행(running)`, `준비(ready)`, `봉쇄(blocked, wait, sleep)` 세가지로 나누어진다.   
  
  * `실행 상태`는 CPU를 할당받아 기계어 명령을 수행하고 있는 프로세스의 상태를 가리킨다.   
  * `준비 상태`는 CPU만 할당받으면 당장 명령을 수행할 수 있지만, 현재 CPU를 할당받지 못한 프로세스의 상태를 말한다.  
  * `봉쇄 상태`는 CPU를 할당받더라도 명령을 수행할 수 없는 프로세스의 상태를 말한다.  
봉쇄상태의 예로는 프로세스가 요청한 입출력 작업이 진행중인 경우를 들 수 있다.  
    
- - - 
   
### 프로세스의 두가지 실행상태  
  
* 하나의 프로세스가 시작되서 수행을 완료할때까지는 프로세스 자신의 주소공간에 있는 코드만 실행되는 것이 아니라 커널의 주소공간에 있는 코드도 실행된다.  
  예를 들어, 프로세스 A가 실행되고 있다고 하면 이는 자신의 주소공간에 정의된 코드를 실행하는것과 커널의 시스템콜 함수를 실행하는것으로 나누어 볼 수 있다.  
* 자신의 주소 공간에서 정의된 코드 실행 : `사용자 모드에서의 실행상태(user mode running)`  
  커널의 시스템 콜 함수를 실행 : `커널 모드에서의 실행상태(kernel mode running)`  
* 이때 한가지 주의할 점은 시스템콜을 통해 실행되는 것이 운영체제 커널의 코드이지만, 시스템콜이 수행되는 동안 커널의 실행상태에 있다고 하지 않고, 프로세스 A가 실행상태에 있다고 말한다.  - > 프로세스A가 커널모드에서 실행중이라고 함.  
* CPU의 제어권이 사용자모드에서 커널모드로 변경되는 경우는 시스템 콜 외에 하드웨어 인터럽트가 발생한 경우도 있다.  
  ex) 프로세스 A의 명령을 CPU가 실행하던 중에 프로세스 B가 예전에 요청했던 입출력이 완료되어, 입출력 컨트롤러가 인터럽트를 발생시킨 경우  
    -> A가 실행되던 중 프로세스가 인터럽트가 발생하면, 발생원인과 관계없이 프로세스 A가 사용자모드에서 실행되다가 커널모드로 진입된것으로 간주한다.   

- - -
    
[출저](https://book.naver.com/bookdb/book_detail.nhn?bid=4392911)  
   
     
     
