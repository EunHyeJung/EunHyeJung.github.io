---
layout: post
title:  "가상메모리-01"
date:   2018-07-22
author: EunHye Jung
categories: os
comment : true
tags:	운영체제 OpeartingSystem OS
cover:  "/assets/instacode.png"
---

   

   

### 가상메모리       
   
   

* 여러 프로그램이 동시에 수행되는 시분할 환경에서는 한정된 메모리 공간을 여러 프로그램이 조금씩 나누어 사용하게 된다.  
* 운영체제는 보통 모든 프로그램에게 공평하게 같은 크기의 메모리를 할당하기 보다는, 몇몇 프로그램들에게 집중적으로 메모리를 할당하는 방식을 채택한다.  
프로세스의 빠른 수행을 위해 프로그램마다 최소한 확보해야 하는 메모리의 크기가 다르게 존재하기 때문이다.  
* 운영체제는 프로그램이 물리적인 메모리를 고려할 필요없이, 마치 자기 자신만의 메모리를 사용하는것처럼 가정해 프로그램하는것을 지원한다.  
프로그램은 0번지부터 시작하는 자신만의 메모리 주소 공간을 가진다고 가정할 수 있는데 이러한 메모리 공간을 `가상 메모리(Virtual Memory)`라고 한다.     
  즉, 가상메모리는 프로세스마다 각각 0번지 부터의 주소공간을 가지게 되며, 이들 공간 중 일부는 물리적 메모리에 적재되고 일부는 디스크의 스왑영역에 존재하게 된다.  
* 프로세스의 주소 공간을 메모리로 적재하는 단위에 따라 가상 메모리 기법은 `요구 페이징(demand paging)` 방식과 `요구 세그먼테이션(demand segmentation)` 방식으로 구현될 수 있다.  
  대부분의 경우 요구 페이징 방식을 사용하며, 요구 세그먼테이션 방식을 사용하는 경우에는 대개 하나의 세그먼트를 여러 개의 페이지로 나누어 관리하느 페이지드 세그먼테이션 기법을 사용하게 된다.  

   
   
- - -    
   
### 요구 페이징(demand paging)  
   
    
* 요구페이징이랑 프로그램 실행시 프로세스를 구성하는 모든 페이지를 한꺼번에 올리는 것이 아니라, 당장 사용될 페이지만을 메모리에 올리는 방식을 말한다.  
  요구페이징 기법에서는 특정 페이지에 대해 CPU의 요청이 들어온 후에야 해당 페이지를 메모리에 적재한다.  
  -> 이 기법을 통해 메모리 사용량을 줄일 수 있고, 프로세스 전체를 메모리에 올리는데 들었던 입출력 오버헤드도 줄일 수 있다.  
  -> 또한, 요구페이징 기법은 프로그램이 물리적 메모리의 용량 제약을 벗어날 수 있도록 해준다.  
    (프로그램을 구성하는 페이지중 일부만을 메모리에 적재하게 되므로, 물리적 메모리의 용량보다 큰 프로그램도 실행할 수 있게 된다.)   
* 요구 페이징에서는 `유효-무효 비트(valid-invalid bit)`를 두어 각 페이지가 메모리에 존재하는지를 표시하게 된다.   
* 프로세스가 실행되기 전에는 모든 페이지의 유효-무효 비트가 무효값으로 초기화되어 있지만, 특정 페이지가  참조되어 메모리에 적재되는 경우 해당 페이지의 유효-무효 비트는 유효값으로 바뀌게 된다.  
  유효-무효 비트값이 무효인 경우는 페이지가 현재 메모리에 없는 경우를 의미할 수 있지만, 경우에 따라서는 그 페이지가 속한 주소 영역을 페이지가 참조하지 않은 경우도 있다.   
   
   
  ![content01](/assets/contents/content09.png)  
   
   
* CPU가 참조하려는 페이지가 현재 메모리에 올라와있지 않아 유효-무효 비트가 무효로 세팅되어 있는 경우를 `페이지 부재(page fault)`라고 한다.  
#### 요구 페이징의 페이지 부재처리   
* CPU가 무효 페이지에 접근하면, 주소 변환을 담당하는 하드웨어인 MMU(Memeory Management Unit)가 페이지 부재 트랩(page fault trap)을 발생시킨다.  
  그러면 CPU의 제어권이 커널 모드(kernel mode)로 전환되고, 운영체제의 페이지 부재 처리 루틴(page fault handler)이 호출되어 페이지 부재를 처리하게 된다.  
  페이지 부재 처리는 다음과 같은 과정을 거쳐 일어난다.  
   1) 운영체제는 해당 페이지에 대한 접근이 문제가 없는지 확인한다.  
    　 사용되지 않은 주소 영역에 속한 페이지를 접근하려 했거나, 해당 페이지에 접근 위반(protection violation)일 경우에는 해당 프로세스를 종료시킨다. (접근 위반의 예로는 읽기 전용 페이지에 대해 쓰기 접근을 시도하려는 경우가 있다.)  
   2) 해당 페이지에 대한 접근이 허용가능한 접근리아면, 물리적 메모리에서 비어있는 프레임(free frame)을 할당받아 그 공간에 페이지를 읽어 온다.    
    　만약 비어 있는 프레임이 없다면 기존에 메모리에 올라와 있는 페이지 중 하나를 디스크의 스왑영역으로 쫓아낸다. (이와 같은 행위를 `스왑 아웃(swap out)`이라고 한다.)  
       
* 요청된 페이지를 디스크로부터 메모리로 적재하기까지는 오랜 시간이 소요된다.  
  따라서 페이지 부재를 발생시킨 프로세스는 CPU를 빼앗기고 봉쇄상태가 된다.  
  그리고 현재까지 수행되던 CPU 레지스터 상태 및 프로그램 카운트 값을 프로세스 제어블록(PCB)에 저장해둔다.  

     
   
- - -  
     
     
### 페이지 교체  
   
* 페이지 부재가 발생하면 요청된 페이지를 디스크에서 메모리로 읽어와야 한다.  
  이때, 물리적 메모리에 빈 프레임이 존재하지 않을수 있다.  
  이러한 경우에는, 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아내 메모리에 빈 공간을 확보하는 작업이 필요하다.  
  -> 이것을 우리는 `페이지 교체(page replacement)`라고 부른다.  
* 페이지 교체를 할 때 어떠한 프레임에 있는 페이지를 쫓아낼 것인지 결정하는 알고리즘은 `페이지 교체 알고리즘(page replacement algorithm)`이라고 한다.  
  이 알고리즘의 목표는 `페이지 부재율을 최소화`하는 것이다.  
  (가까운 미래에 참조될 가능성이 가장 적은 페이지를 선택해서 내쫓는것이 성능을 향상시킬 수 있는 방안이다)  
     
     
- - -
     
     

[출저](https://book.naver.com/bookdb/book_detail.nhn?bid=4392911)  

   

     

     



