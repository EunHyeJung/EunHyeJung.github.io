---
layout: post
title:  "함수리터럴, 함수선언문"
date:   2021-09-14
author: EunHye Jung
categories: javascript
comment : true
tags: 함수리터럴 함수선언문 자바스크립트함수 자바스크립트 JavaScript
cover:  "/assets/instacode.png"
---
    
### 함수리터럴   
    
* 자바스크립트 함수는 객체 타입의 값이다.    
  따라서 숫자값을 숫자리터럴로 생성하고 객체를 객체리터럴로 생성하는것처럼 함수도 함수리터럴로 생성가능하다.  
* 함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다.  
  함수 이름은 함수 몸체 내에서만 참조가능한 식별자다.  
  함수 이름이 있는 함수를 기명함수(named function)라 하고, 이름이 없는 함수를 무명/익명 함수(anonymous function)라고 한다.  
  ex) 함수리터럴 생성 예제
  ```javascript    
  // 변수에 함수리터럴 할당
  var f = function add(x, y) {
      return x + y;
  };
  ```   
* `리터럴`은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기방식을 말한다.  
  즉, 리터럴은 값을 생성하기 위한 표기법이다.  
  따라서 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다 -> 함수는 객체!    
* 함수는 객체지만 일반 객체와는 다르다.  
  일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.  
  그리고 함수는 일반객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.  
* 함수가 객체라는 사실은 다른 프로그래밍언어와 구별되는 자바스크립트의 고유한 특징이다.  
      
- - -  
      
### 함수정의   
    
* 함수정의란 함수를 호출하기 이전에 인수를 전달받은 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말한다.  
* 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다.  
* 함수를 정의하는 방법에는 4가지가 있다.   
  1) 함수 선언문   
     ```javascript  
     function add(x, y) {
        return x + y;
     }
     ```   
  2) 함수 표현식  
     ```javascript
     var add = function(x, y) {
        return x + y;
     };
     ```
  3) Function 생성자 함수  
    ```javascript   
    var add = new Function('x', 'y', 'return x + y');
    ```   
  4) 화살표 함수(ES6)  
     ```javascript  
     var add = (x, y) => x + y; 
     ```       
     
### 함수 선언문    
       
```javascript   
function add(x, y) {
    return x + y;
}
```   
* 함수 선언문은 함수 리터럴과 형태가 동일하다.  
  단, 함수 리터럴은 함수 이름을 생략할 수 있지만 함수 선언문은 함수 이름을 생략할 수 없다.  
* 함수 선언문은 표현식이 아닌 문이다.   
  표현식이 아닌 문은 변수에 할당할 수 없으므로 함수 선언문도 변수에 할당불가능하다.  
  하지만 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수 리터럴을 표현식이 아닌 문인 `함수 선언문`으로 해석하는 경우와 표현식인 문인 `함수 리터럴 표현식`으로 해석하는 경우가 있다.  
  함수 선언문은 함수 이름을 생략할 수 없다는점을 제외하면 함수 리터럴과 형태가 동일하다.  
  이는 함수 이름이 있는 기명함수리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다는 의미이다.  
  따라서 다음과 같이 코드를 실행해도 문제가 발생하지 않는다.  
  ```javascript  
  var add = function add(x, y) {
      return x + y;
  };  
  console.log(add(2, 5));
  ```  
* 자바스크립트 엔진은 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석하고, 함수 리터럴이 값으로 평가되어야 하는 문맥(ex) 함수 리터럴을 변수에 할당하거나 피연산자로 사용하는 경우)으로 사용하면 리터럴 표현식으로 해석한다.   
  이 때 함수 선언문이든 함수 리터럴 표현식이든 함수가 생성되는 것은 동일하지만 함수를 생성하지만 내부 동작에 차이가 있다.   
  ```javascript   
  // 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.  
  // 함수 선언문에서 함수 이름은 생략불가능하다.  
  function foo() {
      console.log('foo');
  }
  foo();    // foo
  
  // 함수리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수리터럴 표현식으로 해석된다.   
  // 함수 리터럴에서는 함수 이름 생략 가능함
  (function bar() {   console.log('bar'); });
  bar();    // ReferenceError: bar is not defined.
  ```   
  함수 선언문과 함수리터럴 표현식은 함수객체를 생성한다는 점에서 동일하지만 호출에 차이가 있다.  
  위 예제에서 함수 선언문으로 생성도니 foo는 호출할 수 있지만 함수리터럴 표현식으로 생성된 bar는 호출할 수 없다.  
  함수리터럴에서 함수이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.  
  이는 함수몸체외부에서는 함수이름으로 함수를 참조할 수 없으므로 호출할 수 없다는 의미이다.   
  (함수를 가리키는 식별자가 없다는것!)   
  하지만 함수 선언문으로 정의된 foo함수는 호출할 수 있었다.  
  자바스크립트 엔진은 함수 선언문을 재해석해 함수 객체를 생성한다.  
  생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에, 함수객체를 할당한다.  
  그리고 함수는 함수이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.  
  이를 의사코드로 표현하면 다음과 같다.   
  ```javascript
   var add = function add(x, y) {
      return x + y;
   };
   console.log(add(2, 5));    // 7
  ```   
  즉, 함수 선언문으로 생성한 함수를 호출한것은 함수 이름 add가 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자인 add인 것이다.  
* 결론직으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 볼 수 있다.  
  단, 함수 선언문과 함수 표현식이 정확히 동일하게 동작하는 것은 아니다.  
       
- - -   
      
[참조(모던 자바스크립트 Deep Dive)](https://book.naver.com/bookdb/book_detail.nhn?bid=16710547)
